/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <string.h>
#include <stdint.h>
#include "stm32f10x.h"
#include "stm32f10x_adc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_can.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_flash.h"
#include "misc.h"
#include "main.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

static __IO uint32_t usTicks=0;
uint32_t 	i, result, temp, address, length;
uint32_t 	CanTrasmitMsgWaitCounter = 0;
uint32_t 	AdcReadWaitCounter = MAX_COUNTDOWN;
uint32_t	CanAddressAdcConvertCounter = MAX_COUNTDOWN;
uint8_t 	IsInitialized = 0;
uint8_t 	status = 0;
uint8_t 	CurrentHeadCanAddress = POSITION_UNPLUGGED; //current head position, which effects the working can bus address of packets sent and received
uint16_t	HeartbeatCounter = 0x1fff;


//Declare the Can Interface's variables
CAN_InitTypeDef 		CAN_InitStructure;
CAN_FilterInitTypeDef 	CAN_FilterInitStructure;
NVIC_InitTypeDef 		NVIC_InitStructure;
CanRxMsg 				CanRxMessage;
CanTxMsg 				CanTxMessage;
uint16_t				CanTxLedStatus = 0x0;
uint16_t				CanRxLedStatus = 0x0;
uint8_t					CanMessageReadyToRead = 0;
uint8_t					CanMessageReadyToSend = 0;
uint8_t 				CanTransmitMailbox;
uint8_t 				CanMessageBuffer[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; //this is a buffer for CAN message transmitting.
uint16_t 				CanRxTargetAddress; 	//Target Address of Received Can message
uint16_t 				CanRxSourceAddress; 	//Source Address of Received Can message
uint32_t				CanRxApplicationData;		//it would be filesize or offset for uploading/downloading firmware.
uint16_t 				CanRxFunctionId; 	//the Function identifier of Received Can message
uint8_t 				CanRxDataBuffer[8]; //the message data buffer of Received Can message

uint16_t                AddressAdcValue=0xFFFF;//invalid value until it starts updating
uint16_t				TempADCReading;

//the variables for Fireware Download/Upload
uint8_t 				IsDownloadApplication = 0;
uint32_t				DownloadApplicationWaitCounter = 0xffff;
uint32_t				DownloadApplicationAddress = 0;
uint8_t 				IsUploadApplication = 0;

AppFunction JumpToApplication;
uint32_t jumpAddress;

// data from the Hot Head Resistor Value and 12-bit ADC Value spec
const HEADPOSITIONTABLE HeadPositionTable[HEAD_POSITION_ENTRIES] = {
	{  108, 91 }, // max adc value for hotbed1 position
	{  294, 26 }, // max adc value for yoke 2 aux2
	{  452, 16 }, // max adc value for yoke 1 aux2
	{  635, 21 }, // max adc value for yoke 2 hot head 1
	{  804, 11 }, // max adc value for yoke 1 hot head 1
	{  943, 22 }, // max adc value for yoke 2 hot head 2
	{ 1082, 12 }, // max adc value for yoke 1 hot head 2
	{ 1228, 23 }, // max adc value for yoke 2 hot head 3
	{ 1389, 13 }, // max adc value for yoke 1 hot head 3
	{ 1563, 24 }, // max adc value for yoke 2 hot head 4
	{ 1751, 14 }, // max adc value for yoke 1 hot head 4
	{ 1946, 25 }, // max adc value for yoke 2 aux1
	{ 2140, 15 }, // max adc value for yoke 1 aux1
	{ 2345, 92 }, // max adc value for hotbed2 position
	{ 2544, 46 }, // max adc value for yoke 4 aux2
	{ 2723, 36 }, // max adc value for yoke 3 aux2
	{ 2901, 41 }, // max adc value for yoke 4 hot head 1
	{ 3065, 31 }, // max adc value for yoke 3 hot head 1
	{ 3200, 42 }, // max adc value for yoke 4 hot head 2
	{ 3317, 32 }, // max adc value for yoke 3 hot head 2
	{ 3439, 43 }, // max adc value for yoke 4 hot head 3
	{ 3557, 33 }, // max adc value for yoke 3 hot head 3
	{ 3667, 44 }, // max adc value for yoke 4 hot head 4
	{ 3780, 34 }, // max adc value for yoke 3 hot head 4
	{ 3906, 45 }, // max adc value for yoke 4 aux1
	{ 4034, 35 }, // max adc value for yoke 3 aux1
	{ MAX_ADC, POSITION_UNPLUGGED } // max adc value an unplugged hothead
};



// SysTick_Handler function will be called every 1 us
void SysTick_Handler(uint32_t us)
{
    if (usTicks != 0)
    {
        usTicks--;
    }
}

void InitRCC()
{
    // Update SystemCoreClock value
    SystemCoreClockUpdate();
    // Configure the SysTick timer to overflow every 1 us
    SysTick_Config(SystemCoreClock / 1000000);


    //Enable GPIOA clock
    RCC->APB2ENR |= (RCC_APB2Periph_GPIOA);		//enable clock for peripheral
    RCC->APB2RSTR &= ~(RCC_APB2Periph_GPIOA);	//remove reset from peripheral

	//Enable GPIOB clock
	RCC->APB2ENR |= (RCC_APB2Periph_GPIOB);
	RCC->APB2RSTR &= ~(RCC_APB2Periph_GPIOB);

	//Enable AFIOEN clock
	RCC->APB2ENR |= (RCC_APB2ENR_AFIOEN);
	RCC->APB2RSTR &= ~(RCC_APB2ENR_AFIOEN);

	//Enable CAN1 clock
	RCC->APB1ENR |= (RCC_APB1Periph_CAN1);
	RCC->APB1RSTR &= ~(RCC_APB1Periph_CAN1);
}



//////////////////////////GPIO FUNCTIONS////////////////////////////////////////////////

//Initialize the GPIO
void InitGPIO()
{
	AFIO->MAPR &= 0xf8ffffff;
	AFIO->MAPR |= 0x02000000; //FOR JTAG
#ifndef OPTIMIZE
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;

	//set pin  for Leds
	GPIO_InitStructure.GPIO_Pin   = LED_B_CANTX | LED_B_CANRX | LED_B_CANRXERROR|
									LED_HEADPOS_00 | LED_HEADPOS_01 | LED_HEADPOS_02| LED_HEADPOS_03;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin   = LED_A_HEARTBEAT; //for heartbeat
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin   = CAN_A_TX;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin   = CAN_A_RX;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin   = SWITCH_B_LEFT | SWITCH_B_RIGHT;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

#else
	GPIOA->CRH = PortAControlBits8_15;
	GPIOB->CRH = PortBControlBits8_15;
	GPIOB->CRL = PortBControlBits0_7;
#endif
	//Reset the Leds.
	GPIOA->BRR = LED_A_HEARTBEAT;
	GPIOB->BRR = LED_B_CANTX;
	GPIOB->BRR = LED_B_CANRX;
	GPIOB->BRR = LED_B_CANRXERROR;
}

//takes the current ADC converted value and adjust the calculates the head address based
// on the HEADPOSITIONTAABLE taable.
//this represents the value from a voltage drivider located on the head, and the yoke
//
void CalculateDevicePosition()
{
	if(AddressAdcValue>0x1000)return;//invalid data, try again later
	for (i = 0; i < HEAD_POSITION_ENTRIES; i++)
	{
		if (AddressAdcValue <= HeadPositionTable[i].adcRaw)
		{
			break;
		}
	}
	if (i == HEAD_POSITION_ENTRIES)
	{
		CurrentHeadCanAddress = POSITION_UNPLUGGED;
		return;
		//reportError1x32(ERROR_UNIT_ADC, ERROR_EXCEEDED_TABLE_LENGTH, (uint32_t)&_blDevicePositionTable[0]);
	}

	switch(HeadPositionTable[i].position)
	{
	case HEAD_01: SetPin(GPIOB, LED_HEADPOS_00); CurrentHeadCanAddress = HEAD_01; break;
	case HEAD_02: SetPin(GPIOB, LED_HEADPOS_01); CurrentHeadCanAddress = HEAD_02;break;
	case HEAD_03: SetPin(GPIOB, LED_HEADPOS_02); CurrentHeadCanAddress = HEAD_03;break;
	case HEAD_04: SetPin(GPIOB, LED_HEADPOS_03); CurrentHeadCanAddress = HEAD_04;break;
	}
}


//////////////////////////ADC FUNCTIONS/////////////////////////////////////////////////////////////////////
void InitADC()		// bootloader version
{
	RCC->CFGR &= CFGR_ADCPRE_Reset_Mask; 					//clock for ADC (max 14MHz --> 72/6=12MHz)
	RCC->CFGR |= RCC_PCLK2_Div6; // 0x0008000

	RCC->APB2ENR |= (RCC_APB2Periph_ADC1);
	RCC->APB2RSTR &= ~(RCC_APB2Periph_ADC1);

	//replace ADC_Init(ADC1, &ADC_InitStructure);   		//set config of ADC1
	ADC1->CR1 &= CR1_CLEAR_Mask;;
	ADC1->CR2 = (ADC1->CR2 & CR2_CLEAR_Mask) | ADC_ExternalTrigConv_None | 0x2;
	ADC1->SQR1 = ADC1->SQR1 & SQR1_CLEAR_Mask;

	//replace ADC_Cmd(ADC1,ENABLE);							//enable ADC1
	ADC1->CR2 |= CR2_ADON_Set;								//enable ADC1

	//  ADC calibration (optional, but recommended at power on)
	//replace ADC_ResetCalibration(ADC1);					// Reset previous calibration
	ADC1->CR2 |= CR2_RSTCAL_Set;
	while(ADC_GetResetCalibrationStatus(ADC1));

	//replace ADC_StartCalibration(ADC1);					// Start new calibration (ADC must be off at that time)
	ADC1->CR2 |= CR2_CAL_Set;
	while(ADC_GetCalibrationStatus(ADC1));					// Wait until calibration is complete

	// adcSetup
	//replaced:
	//ADC_RegularChannelConfig(ADC1, HH_ADC_CHANNEL_POS, 1, ADC_SampleTime_239Cycles5);
	ADC1->SMPR2 = 0x18000000;
	ADC1->SQR3 = 0x00000009;

	//replaced: ADC_Cmd(ADC1, ENABLE); //enable ADC1
	ADC1->CR2 |= CR2_ADON_Set;

	//replaced: ADC_SoftwareStartConvCmd(ADC1, ENABLE);		 // start conversion (will be endless as we are in continuous mode)
	ADC1->CR2 |= CR2_EXTTRIG_SWSTART_Set;
}


//Get the Can Head Address from ADC
void AdcConvertCanAddress()
{
	//TempADCReading= ADC1->DR;
	//StartNextConversion();//start it right away, so it has the most time to do the conversion
	if(AdcReadWaitCounter == MAX_COUNTDOWN) //When ADC value reading start.
	{
		ADC1->SQR3 |= (0<<0);
		ADC1->CR2 |= (1<<0);
	}
	AdcReadWaitCounter --;
	if(AdcReadWaitCounter == 0) //Time's up for reading ADC.
	{
		AdcReadWaitCounter = MAX_COUNTDOWN;
		return;
	}
	if(!(ADC1->SR & (1<<1)))return;//not a valid conversion, so leave without changing anything
	//AddressAdcValue += TempADCReading;//add the valid reading to the last value -------------------------|
	//AddressAdcValue /= 2;//now divide by 2, to perform an average, this will filter out noise -----------| I didn't understand.
	//AddressAdcValue = (ADC1->DR + AddressAdcValue) /2;
	if(AddressAdcValue < MAX_ADC) //it would be not be more than 2048(0x800)
		AddressAdcValue = (ADC1->DR + AddressAdcValue) /2; //now divide by 2, to perform an average, this will filter out noise
	else
		AddressAdcValue = ADC1->DR;
	AdcReadWaitCounter = MAX_COUNTDOWN;
}



//////////////////////////CAN FUNCTIONS////////////////////////////////////////////////////////////////////
/*These fuctions are for CAN*/
//Initialize Can Bus
void InitCAN()
{
	/* CAN register init*/
	CAN_DeInit(CAN1);
	CAN_StructInit(&CAN_InitStructure);

	/* CAN cell init*/
	CAN_InitStructure.CAN_TTCM = DISABLE;
	CAN_InitStructure.CAN_ABOM = DISABLE;
	CAN_InitStructure.CAN_AWUM = DISABLE;
	CAN_InitStructure.CAN_NART = DISABLE;
	CAN_InitStructure.CAN_RFLM = DISABLE;
	CAN_InitStructure.CAN_TXFP = DISABLE;
	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;// ;CAN_Mode_LoopBack is for debug.
	CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
	CAN_InitStructure.CAN_BS1 = CAN_BS1_3tq;
	CAN_InitStructure.CAN_BS2 = CAN_BS2_5tq;
	CAN_InitStructure.CAN_Prescaler = 8;
	CAN_Init(CAN1, &CAN_InitStructure);

	CAN_FilterInitStructure.CAN_FilterNumber = 0;
	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
	CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 1;
	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
	CAN_FilterInit(&CAN_FilterInitStructure);

	/* IT Configuration for CAN1 */
	CAN_ITConfig(CAN1, CAN_IT_FMP1,ENABLE);

	NVIC_InitStructure.NVIC_IRQChannel =  CAN1_RX1_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}


//THis function is a callback for Receiving CAN Message.
void CAN1_RX1_IRQHandler()
{
	//Use the extended message only
	CanRxMessage.ExtId = 0x1FFFFFFF; // reset the CAN Rx message's Extended Id.
	CAN_Receive(CAN1, CAN_FIFO1, &CanRxMessage);

	//Normal Can Message Extended ID format:
	// this version has no Sub-function , it would be 0.
	//				0x00[Target ID (2B)][Source ID (2B)][FunctionId{2B}]
	//Upload/Download Can Message Extended ID format:
	//	function Id would be less than 0x1F because extandted id max value is 1FFFFFFF
	//		- Upload
	//			Start:				0x[FunctionId{2B}][Target ID (2B)][file size{4B}]
	//			During:				0x[FunctionId{2B}][Target ID (2B)][[Offset {4B}]
	//			End:				0x[FunctionId{2B}][Target ID (2B)][written size {4B}]

	//		- Download
	//			Start:				0x[FunctionId{2B}][Target ID (2B)][file size{4B}]
	//			During:				0x[FunctionId{2B}][Target ID (2B)][Offset {4B}]
	//			End:				0x[FunctionId{2B}][Target ID (2B)][read size {4B}]

	CanRxTargetAddress = (CanRxMessage.ExtId >> 16) & 0xFF;
	switch((CanRxMessage.ExtId >> 24) & 0xFF)
	{
	case CAN_NORMAL_MESSAGE: // Normal function message;
		//if(IsDownloadFirware || IsUploadFirware) return; //because it is very busy, it will not be response to anyone

		CanRxFunctionId = CanRxMessage.ExtId  & 0xff;
		CanRxSourceAddress = (CanRxMessage.ExtId >> 8 )& 0xFF;
		break;
	case CAN_UPLOAD_START_APPLICATION:
	case CAN_UPLOADING_APPLICATION:
	case CAN_UPLOAD_END_APPLICATION:
	case CAN_DOWNLOAD_START_APPLICATION:
	case CAN_DOWNLOADING_APPLICATION:
	case CAN_DOWNLOAD_END_APPLICATION:
		CanRxFunctionId = (CanRxMessage.ExtId >> 24) & 0xff;
		CanRxSourceAddress = CAN_DEV_ANALYST;
		CanRxApplicationData = CanRxMessage.ExtId & 0xffff;
		break;
	}
	if(CanRxTargetAddress == CurrentHeadCanAddress) //if Head Address is same as Can message Head identifier.
	{
		memcpy(CanRxDataBuffer, CanRxMessage.Data, CanRxMessage.DLC);
		CanMessageReadyToRead = 1;
	}
}

//////////////////////////////////////////////////
//this function is for sending message thru CAN.
//
// param:
//		target is a head number to send message.
//		funcId means the function identifier of message.
//		data is buffer to send. it must be less than 8bytes.
//		size is the length of buffer.

void SendCanMessage(uint16_t target, uint8_t funcId, uint8_t* data, uint8_t size)
{
	CanTxMessage.ExtId = (target << 16) + (CurrentHeadCanAddress << 8) + funcId;
	CanTxMessage.RTR= CAN_RTR_DATA;
	CanTxMessage.IDE= CAN_ID_EXT;
	CanTxMessage.DLC= size;  //the data size to send, which would be smaller than 8bytes.
	if(size > 0) memcpy(CanTxMessage.Data, data, size); // copy the data to TxMessage's buffer

	CanTransmitMailbox = CAN_Transmit(CAN1, &CanTxMessage);
	CanTrasmitMsgWaitCounter = 0xFFFF; //it would be count down until Can trasmit is ok..
}

//Send ping messsage to all devices.

void PingCanMessage(uint8_t target, uint8_t IsReqeust)
{
	CanMessageBuffer[0] = IsReqeust ? CAN_REQUEST_PING: CAN_RESPONSE_PING;
	SendCanMessage(target, CAN_FUNCTION_PING, CanMessageBuffer, 8);
}
//////////////////////////////////////////////////////////////////////////////////////////////
//Initialize the all variables for bootloader.
void InitVariable()
{
	IsInitialized = 1;
	AdcReadWaitCounter = MAX_COUNTDOWN;
}

// Erase the flash memory with StartAddress and length.
// 		StartAddress : the start Address of flash to erase
//		length : the length of range
//

uint8_t EraseFlash(uint32_t StartAddress, uint32_t size)
{
	result = SUCCESS;
	FLASH_Unlock();
	temp = (size / FLASH_PAGE_SIZE) + 2; // calculate the page size of erase range.
	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
	//FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPTERR | FLASH_FLAG_WRPRTERR);
	for(i = 0; i < temp; i ++)
	{
		if(FLASH_ErasePage(StartAddress +  i * FLASH_PAGE_SIZE) != FLASH_COMPLETE)
		{
			result = ERROR;
			break;
		}
	}
	FLASH_Lock();
	return result;
}
//Write the 32bit data at the address in Flash.
uint8_t WriteFlash(uint32_t address, uint32_t data)
{
	result = SUCCESS;
	FLASH_Unlock();

	if(FLASH_ProgramWord(address, data) != FLASH_COMPLETE)
	{
		result = SUCCESS;
	}

	FLASH_Lock();
	return result;
}

//Write the 8bytes data at the address in Flash.
uint8_t WriteFlash8Bytes(uint32_t addr, uint8_t* data)
{
	result = SUCCESS;
	temp = BYTE2UINT32(data);

	FLASH_Unlock();

	if(FLASH_ProgramWord(addr, temp) != FLASH_COMPLETE)
	{
		result = ERROR;
	}else {
		temp = BYTE2UINT32(data + 4);
		if(FLASH_ProgramWord(addr+ 4, temp) != FLASH_COMPLETE)
		{
			result = ERROR;
		}
	}

	FLASH_Lock();
	return result;
}

//Read the 8bytes data at the address in Flash.
void ReadFlash8Bytes(uint32_t addr, uint8_t* data) //data is 8bytes.
{
	for(i = 0; i < 8; i ++)
		data[i] = *(__IO uint8_t*)(addr+i);
}
uint32_t ReadFlash(uint32_t addr)
{
	temp= *(__IO uint32_t*)(addr);
	return temp;

}

//Convert the 32bit Integer to bytes array.
void ConvertUint32ToBytes(uint32_t integer, uint8_t* bytes)
{
	bytes[3] = (integer >>24); //shift right 24bit
	bytes[2] = (integer >>16); //shift right 16bytes
	bytes[1] = (integer >>8);	//shift right 8bytes
	bytes[0] = (integer & 0xff);
}

typedef void (application_t)(void);

typedef struct
{
    uint32_t		stack_addr;     // Stack Pointer
    application_t*	func_p;        // Program Counter
} JumpStruct;


void DeinitEverything()
{
	//-- reset peripherals to guarantee flawless start of user application
	//HAL_GPIO_DeInit(LED_GPIO_Port, LED_Pin);

	__HAL_RCC_GPIOC_CLK_DISABLE();
	__HAL_RCC_GPIOD_CLK_DISABLE();
	__HAL_RCC_GPIOB_CLK_DISABLE();
	__HAL_RCC_GPIOA_CLK_DISABLE();
	__HAL_RCC_TIM1_CLK_DISABLE();
	__HAL_RCC_SPI1_CLK_DISABLE();
	__HAL_RCC_USART1_CLK_DISABLE();

	RCC_DeInit();

	__HAL_RCC_APB1_FORCE_RESET();
	__HAL_RCC_APB1_RELEASE_RESET();
	__HAL_RCC_APB2_FORCE_RESET();
	__HAL_RCC_APB2_RELEASE_RESET();

	SysTick->CTRL = 0;
	SysTick->LOAD = 0;
	SysTick->VAL = 0;
}
void JumpToApp(const uint32_t address)
{
	const JumpStruct* vector_p = (JumpStruct*)address;

	//__disable_irq();
	DeinitEverything();
	SCB->VTOR = 0x8004000;
	/* let's do The Jump! */
    /* Jump, used asm to avoid stack optimization */
    asm("msr msp, %0; bx %1;" : : "r"(vector_p->stack_addr), "r"(vector_p->func_p));
}
//////////////////////////////////////////////////////////////////////////////////
/// This code doesn't work here.
void applicationMain()
{

//	SysTick->CTRL = 0;
//	SysTick->LOAD = 0;
//	SysTick->VAL  = 0;
//	__disable_irq();
	//SCB->VTOR = FLASH_APPLICATION_START_ADDRESS;
	/* Jump to user application */
	/**
	 * Step: Set jump memory location for system memory
	 *       Use address with 4 bytes offset which specifies jump location where program starts
	 */


	jumpAddress = *(__IO uint32_t*) (FLASH_APPLICATION_START_ADDRESS+ 4); //

	/**
	 * Step: Set main stack pointer.
	 *       This step must be done last otherwise local variables in this function
	 *       don't have proper value since stack pointer is located on different position
	 *
	 *       Set direct address location which specifies stack pointer in SRAM location
	 */
	__set_MSP(*(uint32_t *)FLASH_APPLICATION_START_ADDRESS);

	JumpToApplication = (AppFunction) jumpAddress;
	JumpToApplication();
}
//////////////////////////////////////////////////////////////////////////////////////////

void processCanMsgFunction()
{
	address = BYTE2UINT32(CanRxDataBuffer);
	temp = BYTE2UINT32(CanRxDataBuffer + 4);

	switch(CanRxFunctionId)
	{
	case CAN_FUNCTION_PING: // Response for request ping
		PingCanMessage(CanRxSourceAddress, 0);
		break;
	case CAN_FUNCTION_BLINK_HEARTBEAT:
		break;
	case CAN_FUNCTION_JUMP_TO_APPLICATION:
		//applicationMain();
		JumpToApp(FLASH_APPLICATION_START_ADDRESS);
		//applicationMain();
		break;
	case CAN_FUNCTION_ERASE_FLASH:
		//Data Format: [0-3]: Start Address, [4-7]: Length
		length = BYTE2UINT32(CanRxDataBuffer + 4);
		result = EraseFlash(address, length);
		CanMessageBuffer[0] = result;
		SendCanMessage(CanRxSourceAddress, CAN_FUNCTION_ERASE_FLASH, CanMessageBuffer, 8);
		break;

	case CAN_FUNCTION_WRITE_FLASH:
		//Data Format: [0-3]: Start Address, [4-7]: Data 4bytes
		temp = WriteFlash(address, temp);
		CanMessageBuffer[0] = result;
		SendCanMessage(CanRxSourceAddress, CAN_FUNCTION_WRITE_FLASH, CanMessageBuffer, 8);
		break;

	case CAN_FUNCTION_READ_FLASH:
		//Data Format: [0-3]: Start Address,
		ReadFlash8Bytes(address, CanMessageBuffer); //Read the 8Byte data at the address.
		SendCanMessage(CanRxSourceAddress, CAN_FUNCTION_READ_FLASH, CanMessageBuffer, 8);
		break;

	case CAN_UPLOAD_START_APPLICATION:
		//CanRxApplicationData is file size of firmware to upload.
		//it needs to erase the flash memory range to upload.
		length = CanRxApplicationData;
		result = EraseFlash(FLASH_APPLICATION_SIZE_ADDRESS, CanRxApplicationData); //Add the one page size to register the file size.
		if(result == ERROR)
		{
			//send the error message to Can Analyst-2
			SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_ERROR, CanMessageBuffer, 0);
			IsUploadApplication = 0;
		}
		else
		{
			//at the 0x08004000 address, it write the application file size.
			result = WriteFlash(FLASH_APPLICATION_SIZE_ADDRESS, length);
			if(result == ERROR)
			{
				SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_ERROR, CanMessageBuffer, 0);
				IsUploadApplication = 0;
			}else
			{
				IsUploadApplication = 1;
			}
		}
		break;
	case CAN_UPLOADING_APPLICATION:
		//Write the data at the address in flash
		//CanRxApplicationData is the address to upload
		result = WriteFlash8Bytes(FLASH_APPLICATION_START_ADDRESS + CanRxApplicationData, CanRxDataBuffer);
		if(result == ERROR)
		{
			//if there are errors, send the error message,
			SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_ERROR, CanMessageBuffer, 0);
			IsUploadApplication = 0;
		}
		break;
	case CAN_UPLOAD_END_APPLICATION:
		//Notify the upload end.
		SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_SUCCESS, CanMessageBuffer, 0);
		IsUploadApplication = 0;
		break;
	case CAN_DOWNLOAD_START_APPLICATION: //Notify that the upload has been completed
		//Read the application size at the 0x08004000 address.
		ReadFlash8Bytes(FLASH_APPLICATION_SIZE_ADDRESS, CanMessageBuffer);
		SendCanMessage(CAN_DEV_ANALYST, CAN_DOWNLOAD_START_APPLICATION, CanMessageBuffer, 8);
		DownloadApplicationWaitCounter = MAX_COUNTDOWN;
		IsDownloadApplication = 1;
		break;
	case CAN_DOWNLOADING_APPLICATION: // Send the data of that address
		//uploading frame Id format : 0x[1B][Target ID (2B)][[Address {4B}]
		//Here, CanRxApplicationDat is offset address to read.
		ReadFlash8Bytes(FLASH_APPLICATION_START_ADDRESS + CanRxApplicationData, CanMessageBuffer);
		SendCanMessage(CAN_DEV_ANALYST, CAN_DOWNLOADING_APPLICATION, CanMessageBuffer, 8);
		break;
		IsDownloadApplication = 0;
	case CAN_DOWNLOAD_END_APPLICATION: //Notify that the download has been completed
		SendCanMessage(CAN_DEV_ANALYST, CAN_DOWNLOAD_END_APPLICATION, CanMessageBuffer, 8);
		IsDownloadApplication = 0;
		break;
	}
}
int main(void)
{
	//Initialize RCC, GPIO, ADC, CAN Interfaces.
	InitRCC();//setup internal clock PLL, so we are at 72mhz
	InitGPIO();//set necessary pins for safe boot up and can bus comm
	InitVariable();//initialize working variables

	InitADC();//set up adc, so we can read the address resistor and determine position/can address
	InitCAN();//turn on can transceiver so we can try to register with host.

	for (i=0; i < 500; i ++)
	{
		AdcConvertCanAddress();
		if(AddressAdcValue <= MAX_ADC) break;
		WaitMicrosecond(50);
	}

	// at this point we have clocks and i/o and canbus and adc initialized and working
	//now we will start the registration loop

	//Get the Head position from PB
	CalculateDevicePosition();
	SendCanMessage(CAN_DEV_ANALYST, 0xBB, CanMessageBuffer, 0);
	while(1)
	{
		// we need to put a case here that will fire about 10 times per second
		//it will read the canaddressadc,
		//then update the head address,
		//then send a ping message until it registers

		CanAddressAdcConvertCounter --; //count down AdcConvertCounter to zero
		if(!CanAddressAdcConvertCounter)
		{
			CanAddressAdcConvertCounter = MAX_COUNTDOWN;

			AdcConvertCanAddress(); 	//get the head resister value by adc converting.

			if(AddressAdcValue < 0x7ff) //if successful,
			{
				CalculateDevicePosition(); 	//update the device address with that.
				//if(CurrentHeadCanAddress != POSITION_UNPLUGGED)
					//PingCanMessage();			//send the ping message to all device.
			}
		}

		//lets update the heartbeat now
		HeartbeatCounter --;//count down to zero
		if(HeartbeatCounter & 0x1000)
		{
			TurnOnHeartBeatLed;
		}
		else
		{
			TurnOffHeartBeatLed;
			if(!HeartbeatCounter)	HeartbeatCounter = MAX_COUNTDOWN;//reset the counter if we are at zero
		}

		if(CanTrasmitMsgWaitCounter) //if Can message are transmitting....
		{
			status = CAN_TransmitStatus(CAN1, CanTrasmitMsgWaitCounter); //Get the status of Can Message Transmitting.
			if(status == CANTXOK)
			{
				//when it has done, flags would be reset.
				CanMessageReadyToSend = 1;
				CanTrasmitMsgWaitCounter = 0;
			}
			else //otherwise, counter would be count down to zero.
				CanTrasmitMsgWaitCounter --;
		}

		//set the can traffic transmit led on or off
		if(CanTxLedStatus)
		{
			//get here means the led should be on
			SetCanTxLed;
			CanTxLedStatus --;
		}
		else
		{
			//the led has had enough time to be seen, so now we can turn it off
			ClearCanTxLed; //down count the Can Tx Semaphore
		}

		//set the can traffic receive led on or off
		if(CanRxLedStatus)
		{
			//get here means the led should be on
			SetCanRxLed;
			CanRxLedStatus --; //down count the Can Rx Semaphore.
		}else
		{
			//the led has had enough time to be seen, so now we can turn it off
			ClearCanRxLed;
		}

		///////////////// Toggle Switch Process //////////////////////////////////////////
		if(!ReadToggleSwitchA)
		{
			// if zero, the switch is activated
			TogglePin(GPIOB, LED_HEADPOS_00);
		}
		if(!ReadToggleSwitchB)
		{
			// if zero, the switch is activated
			TogglePin(GPIOB, LED_HEADPOS_01);
		}
		///////////////////////////////////////////////////////////////////////////////////

		//////////////// Can Message Transmitting Process //////////////////////////////
		if(CanTrasmitMsgWaitCounter) //if Can is transsming,
		{
			status = CAN_TransmitStatus(CAN1, CanTransmitMailbox); //Check the Can Transmit status
			if((status != CANTXOK) && (CanTrasmitMsgWaitCounter))
				CanTrasmitMsgWaitCounter --; //Count down the counter for CAN transmit
			else if(status == CANTXOK)
			{
				//if Can transmit successfull, set the flag.
				CanMessageReadyToSend = 1;
				CanTrasmitMsgWaitCounter = 0; //Can Transmit Status set as Idle.
			}
		}

		if (CanMessageReadyToSend)	//if Can transmitting has done.
		{
			//this will be used in response to a memory read request by the host, over the
			//	can bus bootloader, can bus can only send 8 bytes of data at a time,
			//so we will need a counter and pointer to keep track of what memory to read
			//and when we have sent ALL the requested data.
			CanTxLedStatus = MAX_COUNTDOWN;  //set the semaphore Can Tx Led status
			CanMessageReadyToSend = 0; //clear the Can Message Send flag.
		}

		if(CanMessageReadyToRead) // If Can message received.
		{
			//process the message();
			CanRxLedStatus = MAX_COUNTDOWN;//just guessing, but 10,000 loops should be enough time to see the led.
			CanMessageReadyToRead = 0;  //clear the Can Message Rcv flag.
			processCanMsgFunction();
		}
		////////////////////////////////////////////////////////////////////////////////
	}
}
