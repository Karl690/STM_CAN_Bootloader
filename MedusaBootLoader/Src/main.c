/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 * written date: 06/05/2021
 * revision number: SV 1.002
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f10x.h"


#include "main.h"
static volatile uint32_t usTicks=0;
uint32_t 	i, result, temp, address, length;
uint32_t 	CanTrasmitMsgWaitCounter = 0;
uint32_t 	AdcReadWaitCounter = MAX_COUNTDOWN;
uint32_t	CanAddressAdcConvertCounter = MAX_COUNTDOWN;
uint8_t 	IsInitialized = 0;
uint8_t 	status = 0;
uint8_t 	CurrentHeadCanAddress = POSITION_UNPLUGGED; //current head position, which effects the working can bus address of packets sent and received
uint16_t	HeartbeatCounter = 0x1fff;

CanRxMsg 				CanRxMessage;
CanTxMsg 				CanTxMessage;
uint16_t				CanTxLedStatus = 0x0;
uint16_t				CanRxLedStatus = 0x0;
uint8_t					CanMessageReadyToRead = 0;
uint8_t					CanMessageReadyToSend = 0;
uint8_t 				CanTransmitMailbox;
uint8_t 				CanMessageBuffer[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; //this is a buffer for CAN message transmitting.
uint16_t 				CanRxTargetAddress; 	//Target Address of Received Can message
uint16_t 				CanRxSourceAddress; 	//Source Address of Received Can message
uint32_t				CanRxApplicationData;		//it would be filesize or offset for uploading/downloading firmware.
uint16_t 				CanRxFunctionId; 	//the Function identifier of Received Can message
uint8_t 				CanRxDataBuffer[8]; //the message data buffer of Received Can message

uint16_t                AddressAdcValue=0xFFFF;//invalid value until it starts updating
uint16_t				TempADCReading;

//the variables for Fireware Download/Upload
uint32_t				DownloadApplicationWaitCounter = 0xffff;
uint32_t				DownloadApplicationAddress = 0;

FLASH_Status 			flashStatus = FLASH_COMPLETE;
__IO uint32_t 			flashTemp= 0;

// data from the Hot Head Resistor Value and 12-bit ADC Value spec
const uint16_t HeadPositionTable[HEAD_POSITION_ENTRIES] = {
		///(ADC /4 <<6) + Head
		1788, 					//{  108/4, 60(91) }, // max adc value for hotbed1 position
		4698, 		//{  294, 26 }, // max adc value for yoke 2 aux2
		7248 , 		//{  452, 16 }, // max adc value for yoke 1 aux2
		10133, 		//{  635, 21 }, // max adc value for yoke 2 hot head 1
		12875, 		//{  804, 11 }, // max adc value for yoke 1 hot head 1
		15062,		//{  943, 22 }, // max adc value for yoke 2 hot head 2
		17292, 		//{ 1082, 12 }, // max adc value for yoke 1 hot head 2
		19671, 		//{ 1228, 23 }, // max adc value for yoke 2 hot head 3
		22221, 		//{ 1389, 13 }, // max adc value for yoke 1 hot head 3
		24984, 		//{ 1563, 24 }, // max adc value for yoke 2 hot head 4
		27982, 		//{ 1751, 14 }, // max adc value for yoke 1 hot head 4
		31129, 		//{ 1946, 25 }, // max adc value for yoke 2 aux1
		34255, 		//{ 2140, 15 }, // max adc value for yoke 1 aux1
		37565, 		//{ 2345, 61(92) }, // max adc value for hotbed2 position
		40750, 		//{ 2544, 46 }, // max adc value for yoke 4 aux2
		43556, 		//{ 2723, 36 }, // max adc value for yoke 3 aux2
		46441, //{ 2901, 41 }, // max adc value for yoke 4 hot head 1
		49055, //{ 3065, 31 }, // max adc value for yoke 3 hot head 1
		51242, //{ 3200, 42 }, // max adc value for yoke 4 hot head 2
		53088, //{ 3317, 32 }, // max adc value for yoke 3 hot head 2
		55019, //{ 3439, 43 }, // max adc value for yoke 4 hot head 3
		56929,//{ 3557, 33 }, // max adc value for yoke 3 hot head 3
		58668, //{ 3667, 44 }, // max adc value for yoke 4 hot head 4
		60514, //{ 3780, 34 }, // max adc value for yoke 3 hot head 4
		62509, //{ 3906, 45 }, // max adc value for yoke 4 aux1
		64547, //{ 4034, 35 }, // max adc value for yoke 3 aux1
	((MAX_ADC/4)<<6)+POSITION_UNPLUGGED// { MAX_ADC, POSITION_UNPLUGGED } // max adc value an unplugged hothead
};

void InitRCC()
{
    // Update SystemCoreClock value
	//SystemCoreClockUpdate();
    // Configure the SysTick timer to overflow every 1 us
    SysTick_Config(SYSCLK_FREQ_72MHz / 1000000);
    //Enable GPIOA clock
	RCC->APB2ENR |= (RCC_APB2Periph_GPIOA);		//enable clock for peripheral
	RCC->APB2RSTR &= ~(RCC_APB2Periph_GPIOA);	//remove reset from peripheral
	//Enable GPIOB clock
	RCC->APB2ENR |= (RCC_APB2Periph_GPIOB);
	RCC->APB2RSTR &= ~(RCC_APB2Periph_GPIOB);

	//Enable AFIOEN clock
	RCC->APB2ENR |= (RCC_APB2ENR_AFIOEN);
	RCC->APB2RSTR &= ~(RCC_APB2ENR_AFIOEN);

	//Enable CAN1 clock

	RCC->APB1ENR |= (RCC_APB1Periph_CAN1);
	RCC->APB1RSTR &= ~(RCC_APB1Periph_CAN1);

}


// SysTick_Handler function will be called every 1 us
void SysTick_Handler(uint32_t us)
{
    if (usTicks != 0)
    {
        usTicks--;
    }
}

//////////////////////////GPIO FUNCTIONS////////////////////////////////////////////////

//Initialize the GPIO
void InitGPIO()
{
	AFIO->MAPR &= 0xf8ffffff;
	AFIO->MAPR |= 0x02000000; //FOR JTAG
#ifndef OPTIMIZE
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;

	//set pin  for Leds
	GPIO_InitStructure.GPIO_Pin   = LED_B_CANTX | LED_B_CANRX | LED_B_CANRXERROR|
									LED_HEADPOS_00 | LED_HEADPOS_01 | LED_HEADPOS_02| LED_HEADPOS_03;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin   = LED_A_HEARTBEAT; //for heartbeat
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin   = CAN_A_TX;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin   = CAN_A_RX;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin   = SWITCH_B_LEFT | SWITCH_B_RIGHT;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

#else
	GPIOA->CRH = PortAControlBits8_15;
	GPIOB->CRH = PortBControlBits8_15;
	GPIOB->CRL = PortBControlBits0_7;
#endif
	//Reset the Leds.
	GPIOA->BRR = LED_A_HEARTBEAT;
	GPIOB->BRR = LED_B_CANTX;
	GPIOB->BRR = LED_B_CANRX;
	GPIOB->BRR = LED_B_CANRXERROR;
}


//////////////////////////ADC FUNCTIONS/////////////////////////////////////////////////////////////////////


void InitADC()		// bootloader version
{
	RCC->CFGR &= CFGR_ADCPRE_Reset_Mask; 					//clock for ADC (max 14MHz --> 72/6=12MHz)
	RCC->CFGR |= RCC_PCLK2_Div6; // 0x0008000

	RCC->APB2ENR |= (RCC_APB2Periph_ADC1);
	RCC->APB2RSTR &= ~(RCC_APB2Periph_ADC1);

	//replace ADC_Init(ADC1, &ADC_InitStructure);   		//set config of ADC1
	ADC1->CR1 &= CR1_CLEAR_Mask;;
	ADC1->CR2 = (ADC1->CR2 & CR2_CLEAR_Mask) | ADC_ExternalTrigConv_None | 0x2;
	ADC1->SQR1 = ADC1->SQR1 & SQR1_CLEAR_Mask;

	//replace ADC_Cmd(ADC1,ENABLE);							//enable ADC1
	ADC1->CR2 |= CR2_ADON_Set;								//enable ADC1

	//  ADC calibration (optional, but recommended at power on)
	//replace ADC_ResetCalibration(ADC1);					// Reset previous calibration
	ADC1->CR2 |= CR2_RSTCAL_Set;
	//while(ADC_GetResetCalibrationStatus(ADC1));
	while(ADC1->CR2 & CR2_RSTCAL_Set);

	//replace ADC_StartCalibration(ADC1);					// Start new calibration (ADC must be off at that time)
	ADC1->CR2 |= CR2_CAL_Set;
	//ADC_GetCalibrationStatus(ADC1));
	while(ADC1->CR2 & CR2_CAL_Set) ; 			// Wait until calibration is complete

	// adcSetup
	//replaced:
	//ADC_RegularChannelConfig(ADC1, HH_ADC_CHANNEL_POS, 1, ADC_SampleTime_239Cycles5);
	ADC1->SMPR2 = 0x18000000;

	ADC1->SQR3 = 0x00000009;

	//replaced: ADC_Cmd(ADC1, ENABLE); //enable ADC1
	ADC1->CR2 |= CR2_ADON_Set;

	//replaced: ADC_SoftwareStartConvCmd(ADC1, ENABLE);		 // start conversion (will be endless as we are in continuous mode)
	ADC1->CR2 |= CR2_EXTTRIG_SWSTART_Set;
}

//Get the Can Head Address from ADC
void AdcConvertCanAddress()
{
	//TempADCReading= ADC1->DR;
	//StartNextConversion();//start it right away, so it has the most time to do the conversion
	if(AdcReadWaitCounter == MAX_COUNTDOWN) //When ADC value reading start.
	{
		ADC1->SQR3 |= (0<<0);
		ADC1->CR2 |= (1<<0);
	}
	AdcReadWaitCounter --;
	if(AdcReadWaitCounter == 0) //Time's up for reading ADC.
	{
		AdcReadWaitCounter = MAX_COUNTDOWN;
		return;
	}
	if(!(ADC1->SR & (1<<1)))  return;//not a valid conversion, so leave without changing anything
	//AddressAdcValue += TempADCReading;//add the valid reading to the last value -------------------------|
	//AddressAdcValue /= 2;//now divide by 2, to perform an average, this will filter out noise -----------| I didn't understand.
	//AddressAdcValue = (ADC1->DR + AddressAdcValue) /2;
	if(AddressAdcValue < MAX_ADC) //it would be not be more than 2048(0x800)
		AddressAdcValue = (ADC1->DR + AddressAdcValue) /2; //now divide by 2, to perform an average, this will filter out noise
	else
		AddressAdcValue = ADC1->DR;
	AdcReadWaitCounter = MAX_COUNTDOWN;
}
//takes the current ADC converted value and adjust the calculates the head address based
// on the HEADPOSITIONTAABLE taable.
//this represents the value from a voltage drivider located on the head, and the yoke
//
void CalculateDevicePosition()
{
	if(AddressAdcValue>0x1000)return;//invalid data, try again later
	for (i = 0; i < HEAD_POSITION_ENTRIES; i++)
	{
		if (AddressAdcValue <= (HeadPositionTable[i]>>6) * 4)
		{
			break;
		}
	}
	if (i == HEAD_POSITION_ENTRIES)
	{
		CurrentHeadCanAddress = POSITION_UNPLUGGED;
		return;
	}

	switch(HeadPositionTable[i]&0x7F) //Only for 7bit
	{
	case HEAD_01: SetPin(GPIOB, LED_HEADPOS_00); CurrentHeadCanAddress = HEAD_01; break;
	case HEAD_02: SetPin(GPIOB, LED_HEADPOS_01); CurrentHeadCanAddress = HEAD_02;break;
	case HEAD_03: SetPin(GPIOB, LED_HEADPOS_02); CurrentHeadCanAddress = HEAD_03;break;
	case HEAD_04: SetPin(GPIOB, LED_HEADPOS_03); CurrentHeadCanAddress = HEAD_04;break;
	}
}
/////////////////////////////////// CAN Functions //////////////////////////////////////////////////////////////////////


void InitCAN()
{
	/* CAN register init*/
		//First, Deinitializes the CAN peripheral registers to their default reset values.
	RCC->APB1RSTR |= RCC_APB1Periph_CAN1;  /* Enable CAN1 reset state */
	RCC->APB1RSTR &= ~RCC_APB1Periph_CAN1; /* Release CAN1 from reset state */

	temp = 0;
	//Initializes the CAN peripheral according to the specified         parameters in the CAN_InitStruct.(CAN_Init(CAN1, &CAN_InitStructure))
	/* Exit from sleep mode */
	CAN1->MCR &= (~(uint32_t)CAN_MCR_SLEEP);

	/* Request initialisation */
	CAN1->MCR |= CAN_MCR_INRQ ;

	/* Wait the acknowledge */
	while (((CAN1->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (temp != INAK_TIMEOUT))
	{
		temp++;
	}
	/* Set the time triggered communication mode */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_TTCM;  	//CAN_InitStructure.CAN_TTCM = DISABLE;
	/* Set the automatic bus-off management */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_ABOM;	//CAN_InitStructure.CAN_ABOM = DISABLE;
	/* Set the automatic wake-up mode */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_AWUM;
	/* Set the no automatic retransmission */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_NART;	//CAN_InitStructure.CAN_NART = DISABLE;
	/* Set the receive FIFO locked mode */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_RFLM;	//CAN_InitStructure.CAN_RFLM = DISABLE;
	/* Set the transmit FIFO priority */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_TXFP;	//CAN_InitStructure.CAN_TXFP = DISABLE;

	/* Set the bit timing register */
	CAN1->BTR = (uint32_t)((uint32_t)CAN_Mode_Normal << 30) | \
				((uint32_t)CAN_SJW_1tq << 24) | \
				((uint32_t)CAN_BS1_3tq << 16) | \
				((uint32_t)CAN_BS2_5tq << 20) | \
			   ((uint32_t)8 - 1);
	/* Request leave initialisation */
	CAN1->MCR &= ~(uint32_t)CAN_MCR_INRQ;
	/* Wait the acknowledge */
	temp = 0;

	while (((CAN1->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (temp != INAK_TIMEOUT))
	{
		temp++;
	}
	/*End of Initialized Can Init Structure.*/

	/*Initializes the CAN peripheral according to the specified parameters in the CAN_FilterInitStruct.*/
	CAN1->FMR |= FMR_FINIT;
	CAN1->FA1R &= ~(uint32_t)1;
	CAN1->FS1R |= 1;

	 /* 32-bit identifier or First 32-bit identifier */
	CAN1->sFilterRegister[0].FR1 = ((0x0000FFFF & (uint32_t)0) << 16) | (0x0000FFFF & (uint32_t)0);
	/* 32-bit mask or Second 32-bit identifier */
	CAN1->sFilterRegister[0].FR2 = ((0x0000FFFF & (uint32_t)0) << 16) | (0x0000FFFF & (uint32_t)0);

	CAN1->FM1R &= ~(uint32_t)1;
	CAN1->FFA1R |= (uint32_t)1;
	CAN1->FA1R |= 1;
	/* Leave the initialisation mode for the filter */
	CAN1->FMR &= ~FMR_FINIT;
	/*End of Initialized Can Filter Init Structure.*/

	/*Enables the specified CAN1 interrupts.*/
	CAN1->IER |= CAN_IT_FMP1;


	/*Initializes the NVIC peripheral according to the specified parameters in the NVIC_InitStruct.*/
	NVIC->IP[CAN1_RX1_IRQn] = 0;
	/* Enable the Selected IRQ Channels --------------------------------------*/
	NVIC->ISER[CAN1_RX1_IRQn >> 0x05] = (uint32_t)0x01 << (CAN1_RX1_IRQn & (uint8_t)0x1F);
}
/**
  * @brief  Receives a message.
  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
  * @param  RxMessage:  pointer to a structure receive message which contains
  *                     CAN Id, CAN DLC, CAN datas and FMI number.
  * @retval None.
  */
void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
{
  /* Check the parameters */
  /* Get the Id */
  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
  if (RxMessage->IDE == CAN_Id_Standard)
  {
    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
  }
  else
  {
    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
  }

  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
  /* Get the DLC */
  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
  /* Get the FMI */
  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
  /* Get the data field */
  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
  {
    CANx->RF0R |= CAN_RF0R_RFOM0;
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CANx->RF1R |= CAN_RF1R_RFOM1;
  }
}

//THis function is a callback for Receiving CAN Message.
void CAN1_RX1_IRQHandler()
{
	CAN_Receive(CAN1, CAN_FIFO1, &CanRxMessage);
	CanRxTargetAddress = (CanRxMessage.ExtId >> 16) & 0xFF;
	if(CanRxTargetAddress == CurrentHeadCanAddress) //if Head Address is same as Can message Head identifier.
	{
		switch((CanRxMessage.ExtId >> 24) & 0xFF)
		{
		case CAN_NORMAL_MESSAGE: // Normal function message;
			//if(IsDownloadFirware || IsUploadFirware) return; //because it is very busy, it will not be response to anyone

			CanRxFunctionId = CanRxMessage.ExtId  & 0xff;
			CanRxSourceAddress = (CanRxMessage.ExtId >> 8 )& 0xFF;
			break;
		case CAN_UPLOAD_START_APPLICATION:
		case CAN_UPLOADING_APPLICATION:
		case CAN_UPLOAD_END_APPLICATION:
		case CAN_DOWNLOAD_START_APPLICATION:
		case CAN_DOWNLOADING_APPLICATION:
		case CAN_DOWNLOAD_END_APPLICATION:
			CanRxFunctionId = (CanRxMessage.ExtId >> 24) & 0xff;
			CanRxSourceAddress = CAN_DEV_ANALYST;
			CanRxApplicationData = CanRxMessage.ExtId & 0xffff;
			break;
		}

		memcpy(CanRxDataBuffer, CanRxMessage.Data, CanRxMessage.DLC);
		CanMessageReadyToRead = 1;
	}
}

//////////////////////////////////////////////////
//this function is for sending message thru CAN.
//
// param:
//		target is a head number to send message.
//		funcId means the function identifier of message.
//		data is buffer to send. it must be less than 8bytes.
//		size is the length of buffer.

void SendCanMessage(uint16_t target, uint8_t funcId, uint8_t* data, uint8_t size)
{
	temp = (target << 16) + (CurrentHeadCanAddress << 8) + funcId; //this is Ext ID
	//CanTxMessage.RTR= CAN_RTR_DATA;
	//CanTxMessage.IDE= CAN_ID_EXT;
	//CanTxMessage.DLC= size;  //the data size to send, which would be smaller than 8bytes.
	if(size > 0) memcpy(CanTxMessage.Data, data, size); // copy the data to TxMessage's buffer

	/* Select one empty transmit mailbox */
	if ((CAN1->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
	{
		CanTransmitMailbox = 0;
	}
	else if ((CAN1->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
	{
		CanTransmitMailbox = 1;
	}
	else if ((CAN1->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
	{
		CanTransmitMailbox = 2;
	}
	else
	{
		CanTransmitMailbox = CAN_TxStatus_NoMailBox;
	}

	if (CanTransmitMailbox != CAN_TxStatus_NoMailBox) {
		CAN1->sTxMailBox[CanTransmitMailbox].TIR &= TMIDxR_TXRQ;

		CAN1->sTxMailBox[CanTransmitMailbox].TIR |= ((temp << 3) | \
													CAN_Id_Extended | \
														CAN_RTR_Data);

		/* Set up the DLC */

		CAN1->sTxMailBox[CanTransmitMailbox].TDTR &= (uint32_t)0xFFFFFFF0;
		CAN1->sTxMailBox[CanTransmitMailbox].TDTR |= size; //Data Size

		/* Set up the data field */
		CAN1->sTxMailBox[CanTransmitMailbox].TDLR = (((uint32_t)data[3] << 24) |
												 ((uint32_t)data[2] << 16) |
												 ((uint32_t)data[1] << 8) |
												 ((uint32_t)data[0]));
		CAN1->sTxMailBox[CanTransmitMailbox].TDHR = (((uint32_t)data[7] << 24) |
												 ((uint32_t)data[6] << 16) |
												 ((uint32_t)data[5] << 8) |
												 ((uint32_t)data[4]));
		/* Request transmission */
		CAN1->sTxMailBox[CanTransmitMailbox].TIR |= TMIDxR_TXRQ;
	}
	//CanTransmitMailbox = CAN_Transmit(CAN1, &CanTxMessage);
	CanTrasmitMsgWaitCounter = 0xFFFF; //it would be count down until Can trasmit is ok..
}

/**
  * @brief  Checks the transmission of a message.
  * @param  CANx:            where x can be 1 or 2 to to select the
  *                          CAN peripheral.
  * @param  TransmitMailbox: the number of the mailbox that is used for
  *                          transmission.
  * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, CAN_TxStatus_Failed
  *         in an other case.
  */
uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
{
  uint32_t state = 0;

  switch (TransmitMailbox)
  {
    case (CAN_TXMAILBOX_0):
      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
      break;
    case (CAN_TXMAILBOX_1):
      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
      break;
    case (CAN_TXMAILBOX_2):
      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
      break;
    default:
      state = CAN_TxStatus_Failed;
      break;
  }
  switch (state)
  {
      /* transmit pending  */
    case (0x0): state = CAN_TxStatus_Pending;
      break;
      /* transmit failed  */
     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
      break;
     case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
      break;
     case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
      break;
      /* transmit succeeded  */
    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
      break;
    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
      break;
    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
      break;
    default: state = CAN_TxStatus_Failed;
      break;
  }
  return (uint8_t) state;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
  RCC->CFGR &= (uint32_t)0xF8FF0000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;

}

void DeinitEverything()
{
	__HAL_RCC_GPIOC_CLK_DISABLE();
	__HAL_RCC_GPIOD_CLK_DISABLE();
	__HAL_RCC_GPIOB_CLK_DISABLE();
	__HAL_RCC_GPIOA_CLK_DISABLE();
	__HAL_RCC_TIM1_CLK_DISABLE();
	__HAL_RCC_SPI1_CLK_DISABLE();
	__HAL_RCC_USART1_CLK_DISABLE();

	RCC_DeInit();

	__HAL_RCC_APB1_FORCE_RESET();
	__HAL_RCC_APB1_RELEASE_RESET();
	__HAL_RCC_APB2_FORCE_RESET();
	__HAL_RCC_APB2_RELEASE_RESET();

	SysTick->CTRL = 0;
	SysTick->LOAD = 0;
	SysTick->VAL = 0;
}

void jumpToApp(const uint32_t address)
{
	const JumpStruct* vector_p = (JumpStruct*)address;
	DeinitEverything();
	SCB->VTOR = FLASH_APPLICATION_OFFSET_ADDRESS;

	/* let's do The Jump! */
    /* Jump, used asm to avoid stack optimization */
    asm("msr msp, %0; bx %1;" : : "r"(vector_p->stack_addr), "r"(vector_p->func_p));
}

//////////////////////////////////////// Flash functions ///////////////////////////////////////////

/**
  * @brief  Unlocks the FLASH Program Erase Controller.
  * @note   This function can be used for all STM32F10x devices.
  *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.
  *         - For all other devices it unlocks Bank1 and it is equivalent
  *           to FLASH_UnlockBank1 function..
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
  FLASH->KEYR = FLASH_KEY2;
}

/**
  * @brief  Locks the FLASH Program Erase Controller.
  * @note   This function can be used for all STM32F10x devices.
  *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.
  *         - For all other devices it Locks Bank1 and it is equivalent
  *           to FLASH_LockBank1 function.
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
  FLASH->CR |= CR_LOCK_Set;
}


/**
  * @brief  Clears the FLASH's pending flags.
  * @note   This function can be used for all STM32F10x devices.
  *         - For STM32F10X_XL devices, this function clears Bank1 or Bank2’s pending flags
  *         - For other devices, it clears Bank1’s pending flags.
  * @param  FLASH_FLAG: specifies the FLASH flags to clear.
  *   This parameter can be any combination of the following values:
  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag
  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag
  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
}

/**
  * @brief  Returns the FLASH Bank1 Status.
  * @note   This function can be used for all STM32F10x devices, it is equivalent
  *         to FLASH_GetStatus function.
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP or FLASH_COMPLETE
  */
FLASH_Status FLASH_GetBank1Status(void)
{

  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY)
    return FLASH_BUSY;
  if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
      return FLASH_ERROR_PG;
  if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
	  return FLASH_ERROR_WRP;
  return  FLASH_COMPLETE;
}
/**
  * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
  * @note   This function can be used for all STM32F10x devices,
  *         it is equivalent to FLASH_WaitForLastBank1Operation.
  *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation
  *           to complete or a TIMEOUT to occur.
  *         - For all other devices it waits for a Flash operation to complete
  *           or a TIMEOUT to occur.
  * @param  Timeout: FLASH programming Timeout
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
{
	flashStatus = FLASH_COMPLETE;

  /* Check for the Flash Status */
	flashStatus = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
	while((flashStatus == FLASH_BUSY) && (Timeout != 0x00))
	{
		flashStatus = FLASH_GetBank1Status();
		Timeout--;
  	}
	if(Timeout == 0x00 )
  	{
  		flashStatus = FLASH_TIMEOUT;
  	}
  /* Return the operation status */
	return flashStatus;
}


/**
  * @brief  Erases a specified FLASH page.
  * @note   This function can be used for all STM32F10x devices.
  * @param  Page_Address: The page address to be erased.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
{
  /* Wait for last operation to be completed */
  if(FLASH_WaitForLastOperation(EraseTimeout) != FLASH_COMPLETE) return FLASH_ERROR_PG;
  /* if the previous operation is completed, proceed to erase the page */
	FLASH->CR|= CR_PER_Set;
	FLASH->AR = Page_Address;
	FLASH->CR|= CR_STRT_Set;

	/* Wait for last operation to be completed */
	FLASH_WaitForLastOperation(EraseTimeout);
	/* Disable the PER Bit */
	FLASH->CR &= CR_PER_Reset;

  /* Return the Erase Status */
	return FLASH_COMPLETE;
}

/**
  * @brief  Programs a word at a specified address.
  * @note   This function can be used for all STM32F10x devices.
  * @param  Address: specifies the address to be programmed.
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
  /* Wait for last operation to be completed */
  flashStatus = FLASH_WaitForLastOperation(ProgramTimeout);

  if(flashStatus != FLASH_COMPLETE) return flashStatus;

	/* if the previous operation is completed, proceed to program the new first
	half word */
	FLASH->CR |= CR_PG_Set;

	*(__IO uint16_t*)Address = (uint16_t)Data;
	/* Wait for last operation to be completed */
	flashStatus = FLASH_WaitForLastOperation(ProgramTimeout);

	if(flashStatus == FLASH_COMPLETE)
	{
	  /* if the previous operation is completed, proceed to program the new second
	  half word */
	  flashTemp = Address + 2;

	  *(__IO uint16_t*) flashTemp = Data >> 16;

	  /* Wait for last operation to be completed */
	  flashStatus = FLASH_WaitForLastOperation(ProgramTimeout);

	  /* Disable the PG Bit */
	  FLASH->CR &= CR_PG_Reset;
	}
	else
	{
	  /* Disable the PG Bit */
	  FLASH->CR &= CR_PG_Reset;
	}

  /* Return the Program Status */
  return flashStatus;
}



// Erase the flash memory with StartAddress and length.
// 		StartAddress : the start Address of flash to erase
//		length : the length of range
//

uint8_t EraseFlash(uint32_t StartAddress, uint32_t size)
{
	result = SUCCESS;
	FLASH_Unlock();

	temp = (size / FLASH_PAGE_SIZE) + 2; // calculate the page size of erase range.
	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
	//FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPTERR | FLASH_FLAG_WRPRTERR);
	for(i = 0; i < temp; i ++)
	{
		if(FLASH_ErasePage(StartAddress +  i * FLASH_PAGE_SIZE) != FLASH_COMPLETE)
		{
			result = ERROR;
			break;
		}
	}
	FLASH_Lock();
	return result;
}
//Write the 32bit data at the address in Flash.
uint8_t WriteFlash(uint32_t address, uint32_t data)
{
	result = SUCCESS;
	FLASH_Unlock();

	if(FLASH_ProgramWord(address, data) != FLASH_COMPLETE)
	{
		result = SUCCESS;
	}

	FLASH_Lock();
	return result;
}

//Write the 8bytes data at the address in Flash.
uint8_t WriteFlash8Bytes(uint32_t addr, uint8_t* data)
{
	result = SUCCESS;
	temp = BYTE2UINT32(data[3], data[2], data[1], data[0]);

	FLASH_Unlock();

	if(FLASH_ProgramWord(addr, temp) != FLASH_COMPLETE)
	{
		result = ERROR;
	}else {
		temp = BYTE2UINT32(data[7], data[6], data[5], data[4]);
		if(FLASH_ProgramWord(addr+ 4, temp) != FLASH_COMPLETE)
		{
			result = ERROR;
		}
	}

	FLASH_Lock();
	return result;
}

//Read the 8bytes data at the address in Flash.
void ReadFlash8Bytes(uint32_t addr, uint8_t* data) //data is 8bytes.
{
	for(i = 0; i < 8; i ++)
		data[i] = *(__IO uint8_t*)(addr+i);
}
//Read the 32bit data at the address in Flash
uint32_t ReadFlash(uint32_t addr)
{
	return  *(__IO uint32_t*)(addr);
}


////////////////////////////////////////////////////////////////////////////////////////////

void processCanMsgFunction()
{
	address = BYTE2UINT32(CanRxDataBuffer[3], CanRxDataBuffer[2], CanRxDataBuffer[1],CanRxDataBuffer[0]);
	temp = BYTE2UINT32(CanRxDataBuffer[7], CanRxDataBuffer[6], CanRxDataBuffer[5],CanRxDataBuffer[4]);

	switch(CanRxFunctionId)
	{
	case CAN_FUNCTION_PING: // Response for request ping
		SendCanMessage(CAN_DEV_ANALYST, CAN_FUNCTION_PING, CanMessageBuffer, 0);
		break;
	case CAN_FUNCTION_BLINK_HEARTBEAT:
		break;
	case CAN_FUNCTION_JUMP_TO_APPLICATION:
		jumpToApp(FLASH_APPLICATION_START_ADDRESS);
		break;
	case CAN_FUNCTION_ERASE_FLASH:
		//Data Format: [0-3]: Start Address, [4-7]: Length
		length = BYTE2UINT32(CanRxDataBuffer[7], CanRxDataBuffer[6],CanRxDataBuffer[5],CanRxDataBuffer[4]);
		result = EraseFlash(address, length);
		CanMessageBuffer[0] = result;
		SendCanMessage(CanRxSourceAddress, CAN_FUNCTION_ERASE_FLASH, CanMessageBuffer, 8);
		break;

	case CAN_FUNCTION_WRITE_FLASH:
		//Data Format: [0-3]: Start Address, [4-7]: Data 4bytes
		temp = WriteFlash(address, temp);
		CanMessageBuffer[0] = result;
		SendCanMessage(CanRxSourceAddress, CAN_FUNCTION_WRITE_FLASH, CanMessageBuffer, 8);
		break;

	case CAN_FUNCTION_READ_FLASH:
		//Data Format: [0-3]: Start Address,
		ReadFlash8Bytes(address, CanMessageBuffer); //Read the 8Byte data at the address.
		SendCanMessage(CanRxSourceAddress, CAN_FUNCTION_READ_FLASH, CanMessageBuffer, 8);
		break;

	case CAN_UPLOAD_START_APPLICATION:
		//CanRxApplicationData is file size of firmware to upload.
		//it needs to erase the flash memory range to upload.
		length = CanRxApplicationData;
		if( EraseFlash(FLASH_APPLICATION_SIZE_ADDRESS, CanRxApplicationData)  == ERROR) //Add the one page size to register the file size.
		{
			//send the error message to Can Analyst-2
			SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_ERROR, CanMessageBuffer, 0);
		}
		else
		{
			//at the 0x08004000 address, it write the application file size.
			if(WriteFlash(FLASH_APPLICATION_SIZE_ADDRESS, length) == ERROR)
			{
				SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_ERROR, CanMessageBuffer, 0);
			}
		}
		break;
	case CAN_UPLOADING_APPLICATION:
		if(WriteFlash8Bytes(FLASH_APPLICATION_START_ADDRESS + CanRxApplicationData, CanRxDataBuffer) == ERROR)
		{
			SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_ERROR, CanMessageBuffer, 0);
		}
		break;
	case CAN_UPLOAD_END_APPLICATION:
		//Notify the upload end.
		SendCanMessage(CAN_DEV_ANALYST, CAN_APPLICATION_UPLOADDOWNLOAD_SUCCESS, CanMessageBuffer, 0);
		break;
	case CAN_DOWNLOAD_START_APPLICATION:
		//Read the application size at the 0x08004000 address.
		ReadFlash8Bytes(FLASH_APPLICATION_SIZE_ADDRESS, CanMessageBuffer);
		SendCanMessage(CAN_DEV_ANALYST, CAN_DOWNLOAD_START_APPLICATION, CanMessageBuffer, 8);
		DownloadApplicationWaitCounter = MAX_COUNTDOWN;
		break;
	case CAN_DOWNLOADING_APPLICATION:
		//uploading frame Id format : 0x[1B][Target ID (2B)][[Address {4B}]
		//Here, CanRxApplicationDat is offset address to read.
		ReadFlash8Bytes(FLASH_APPLICATION_START_ADDRESS + CanRxApplicationData, CanMessageBuffer);
		SendCanMessage(CAN_DEV_ANALYST, CAN_DOWNLOADING_APPLICATION, CanMessageBuffer, 8);
		break;
	case CAN_DOWNLOAD_END_APPLICATION:
		SendCanMessage(CAN_DEV_ANALYST, CAN_DOWNLOAD_END_APPLICATION, CanMessageBuffer, 8);
		break;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(void)
{
	InitRCC();
	InitGPIO();

	InitADC();

	InitCAN();

	for (i=0; i < 500; i ++)
	{
		AdcConvertCanAddress();
		if(AddressAdcValue <= MAX_ADC) break;
		WaitMicrosecond(50);
	}


	SendCanMessage(CAN_DEV_ANALYST, 0xBB, CanMessageBuffer, 0);
    /* Loop forever */
	while(1){
		//lets update the heartbeat now
		HeartbeatCounter --;//count down to zero
		if(HeartbeatCounter & 0x1000)
		{
			TurnOnHeartBeatLed;
		}
		else
		{
			TurnOffHeartBeatLed;
			if(!HeartbeatCounter)	HeartbeatCounter = MAX_COUNTDOWN;//reset the counter if we are at zero
		}


    	CanAddressAdcConvertCounter --; //count down AdcConvertCounter to zero
    	if(!CanAddressAdcConvertCounter)
    	{
    		CanAddressAdcConvertCounter = MAX_COUNTDOWN;

    		AdcConvertCanAddress(); 	//get the head resister value by adc converting.

    		if(AddressAdcValue < 0x7ff) //if successful,
    		{
    			CalculateDevicePosition(); 	//update the device address with that.
				//if(CurrentHeadCanAddress != POSITION_UNPLUGGED)
					//PingCanMessage();			//send the ping message to all device.
    		}
    	}

    	// we need to put a case here that will fire about 10 times per second
		//it will read the canaddressadc,
		//then update the head address,
		//then send a ping message until it registers

    	CanAddressAdcConvertCounter --; //count down AdcConvertCounter to zero
    	if(!CanAddressAdcConvertCounter)
    	{
    		CanAddressAdcConvertCounter = MAX_COUNTDOWN;

    		AdcConvertCanAddress(); 	//get the head resister value by adc converting.

    		if(AddressAdcValue < 0x7ff) //if successful,
    		{
    			CalculateDevicePosition(); 	//update the device address with that.
				//if(CurrentHeadCanAddress != POSITION_UNPLUGGED)
					//PingCanMessage();			//send the ping message to all device.
    		}
    	}



    	//////////////// Can Message Transmitting Process //////////////////////////////
    	if(CanTrasmitMsgWaitCounter) //if Can is transsming,
    	{
    		status = CAN_TransmitStatus(CAN1, CanTransmitMailbox); //Check the Can Transmit status
    		if((status != CAN_TxStatus_Ok) && (CanTrasmitMsgWaitCounter))
    			CanTrasmitMsgWaitCounter --; //Count down the counter for CAN transmit
    		else if(status == CAN_TxStatus_Ok)
    		{
    			//if Can transmit successfull, set the flag.
    			CanMessageReadyToSend = 1;
    			CanTrasmitMsgWaitCounter = 0; //Can Transmit Status set as Idle.
    		}
    	}
    	if (CanMessageReadyToSend)	//if Can transmitting has done.
		{
			//this will be used in response to a memory read request by the host, over the
			//	can bus bootloader, can bus can only send 8 bytes of data at a time,
			//so we will need a counter and pointer to keep track of what memory to read
			//and when we have sent ALL the requested data.
			CanTxLedStatus = MAX_COUNTDOWN;  //set the semaphore Can Tx Led status
			CanMessageReadyToSend = 0; //clear the Can Message Send flag.
		}

		if(CanMessageReadyToRead) // If Can message received.
		{
			//process the message();
			CanRxLedStatus = MAX_COUNTDOWN;//just guessing, but 10,000 loops should be enough time to see the led.
			CanMessageReadyToRead = 0;  //clear the Can Message Rcv flag.
			processCanMsgFunction();
		}
    	//set the can traffic transmit led on or off
		if(CanTxLedStatus)
		{
			//get here means the led should be on
			SetCanTxLed;
			CanTxLedStatus --;
		}
		else
		{
			//the led has had enough time to be seen, so now we can turn it off
			ClearCanTxLed; //down count the Can Tx Semaphore
		}

		//set the can traffic receive led on or off
		if(CanRxLedStatus)
		{
			//get here means the led should be on
			SetCanRxLed;
			CanRxLedStatus --; //down count the Can Rx Semaphore.
		}else
		{
			//the led has had enough time to be seen, so now we can turn it off
			ClearCanRxLed;
		}
	}
}
